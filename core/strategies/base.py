"""
Base strategy interface and abstract classes for trading strategies.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Tuple
from enum import Enum
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class SignalType(str, Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"


class StrategyStatus(str, Enum):
    """Strategy execution status."""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""
    signal_type: SignalType
    token_in: str
    token_out: str
    amount: float
    confidence: float  # 0.0 to 1.0
    timestamp: datetime
    metadata: Dict[str, Any]
    strategy_id: str
    reason: str


@dataclass
class MarketData:
    """Market data structure for strategy analysis."""
    symbol: str
    price: float
    volume_24h: float
    price_change_24h: float
    market_cap: Optional[float] = None
    timestamp: datetime = None
    additional_data: Dict[str, Any] = None


@dataclass
class PortfolioPosition:
    """Represents a portfolio position."""
    token: str
    balance: float
    value_usd: float
    price_usd: float
    percentage: float


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy."""
    strategy_id: str
    name: str
    description: str
    parameters: Dict[str, Any]
    risk_limits: Dict[str, float]
    enabled: bool = True


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All trading strategies must inherit from this class and implement
    the required abstract methods.
    """
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.status = StrategyStatus.INACTIVE
        self.last_signal: Optional[TradingSignal] = None
        self.performance_metrics: Dict[str, float] = {}
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
    
    @abstractmethod
    async def analyze_market(self, market_data: List[MarketData]) -> Optional[TradingSignal]:
        """
        Analyze market data and generate trading signals.
        
        Args:
            market_data: List of market data for analysis
            
        Returns:
            TradingSignal if a signal is generated, None otherwise
        """
        pass
    
    @abstractmethod
    async def validate_signal(self, signal: TradingSignal, portfolio: List[PortfolioPosition]) -> bool:
        """
        Validate a trading signal against current portfolio and risk limits.
        
        Args:
            signal: The trading signal to validate
            portfolio: Current portfolio positions
            
        Returns:
            True if signal is valid, False otherwise
        """
        pass
    
    @abstractmethod
    def get_required_data(self) -> List[str]:
        """
        Get list of required market data symbols for this strategy.
        
        Returns:
            List of token symbols required for analysis
        """
        pass
    
    async def start(self):
        """Start the strategy execution."""
        self.status = StrategyStatus.ACTIVE
        self.logger.info(f"Strategy {self.config.strategy_id} started")
    
    async def stop(self):
        """Stop the strategy execution."""
        self.status = StrategyStatus.INACTIVE
        self.logger.info(f"Strategy {self.config.strategy_id} stopped")
    
    async def pause(self):
        """Pause the strategy execution."""
        self.status = StrategyStatus.PAUSED
        self.logger.info(f"Strategy {self.config.strategy_id} paused")
    
    async def resume(self):
        """Resume the strategy execution."""
        self.status = StrategyStatus.ACTIVE
        self.logger.info(f"Strategy {self.config.strategy_id} resumed")
    
    def update_config(self, new_config: StrategyConfig):
        """Update strategy configuration."""
        self.config = new_config
        self.logger.info(f"Strategy {self.config.strategy_id} configuration updated")
    
    def get_performance_metrics(self) -> Dict[str, float]:
        """Get current performance metrics."""
        return self.performance_metrics.copy()
    
    def update_performance_metrics(self, metrics: Dict[str, float]):
        """Update performance metrics."""
        self.performance_metrics.update(metrics)
    
    def check_risk_limits(self, signal: TradingSignal, portfolio: List[PortfolioPosition]) -> bool:
        """
        Check if a signal violates risk limits.
        
        Args:
            signal: Trading signal to check
            portfolio: Current portfolio positions
            
        Returns:
            True if within risk limits, False otherwise
        """
        risk_limits = self.config.risk_limits
        
        # Check maximum position size
        max_position_size = risk_limits.get("max_position_size", 0.1)
        total_portfolio_value = sum(pos.value_usd for pos in portfolio)
        
        if total_portfolio_value > 0:
            signal_value = signal.amount * self._get_token_price(signal.token_in)
            position_percentage = signal_value / total_portfolio_value
            
            if position_percentage > max_position_size:
                self.logger.warning(f"Signal exceeds max position size: {position_percentage:.2%} > {max_position_size:.2%}")
                return False
        
        # Check minimum confidence
        min_confidence = risk_limits.get("min_confidence", 0.5)
        if signal.confidence < min_confidence:
            self.logger.warning(f"Signal confidence too low: {signal.confidence:.2f} < {min_confidence:.2f}")
            return False
        
        return True
    
    def _get_token_price(self, token: str) -> float:
        """
        Get current price for a token.
        This is a placeholder - in real implementation, this would
        fetch from market data provider.
        """
        # TODO: Implement actual price fetching
        return 1.0


class StrategyRegistry:
    """
    Registry for managing trading strategies.
    
    Provides centralized management of strategy instances,
    configuration, and execution.
    """
    
    def __init__(self):
        self._strategies: Dict[str, BaseStrategy] = {}
        self._strategy_classes: Dict[str, type] = {}
        self.logger = logging.getLogger(__name__)
    
    def register_strategy_class(self, name: str, strategy_class: type):
        """
        Register a strategy class.
        
        Args:
            name: Strategy class name
            strategy_class: Strategy class type
        """
        if not issubclass(strategy_class, BaseStrategy):
            raise ValueError(f"Strategy class must inherit from BaseStrategy")
        
        self._strategy_classes[name] = strategy_class
        self.logger.info(f"Registered strategy class: {name}")
    
    def create_strategy(self, strategy_type: str, config: StrategyConfig) -> BaseStrategy:
        """
        Create a new strategy instance.
        
        Args:
            strategy_type: Type of strategy to create
            config: Strategy configuration
            
        Returns:
            Strategy instance
        """
        if strategy_type not in self._strategy_classes:
            raise ValueError(f"Unknown strategy type: {strategy_type}")
        
        strategy_class = self._strategy_classes[strategy_type]
        strategy = strategy_class(config)
        
        self._strategies[config.strategy_id] = strategy
        self.logger.info(f"Created strategy: {config.strategy_id} ({strategy_type})")
        
        return strategy
    
    def get_strategy(self, strategy_id: str) -> Optional[BaseStrategy]:
        """Get strategy by ID."""
        return self._strategies.get(strategy_id)
    
    def list_strategies(self) -> List[BaseStrategy]:
        """Get list of all strategies."""
        return list(self._strategies.values())
    
    def list_active_strategies(self) -> List[BaseStrategy]:
        """Get list of active strategies."""
        return [s for s in self._strategies.values() if s.status == StrategyStatus.ACTIVE]
    
    def remove_strategy(self, strategy_id: str) -> bool:
        """
        Remove a strategy from the registry.
        
        Args:
            strategy_id: ID of strategy to remove
            
        Returns:
            True if removed, False if not found
        """
        if strategy_id in self._strategies:
            strategy = self._strategies[strategy_id]
            if strategy.status == StrategyStatus.ACTIVE:
                strategy.stop()
            
            del self._strategies[strategy_id]
            self.logger.info(f"Removed strategy: {strategy_id}")
            return True
        
        return False
    
    async def start_all_strategies(self):
        """Start all registered strategies."""
        for strategy in self._strategies.values():
            if strategy.config.enabled:
                await strategy.start()
    
    async def stop_all_strategies(self):
        """Stop all registered strategies."""
        for strategy in self._strategies.values():
            await strategy.stop()
    
    def get_available_strategy_types(self) -> List[str]:
        """Get list of available strategy types."""
        return list(self._strategy_classes.keys())


# Global strategy registry instance
strategy_registry = StrategyRegistry()

